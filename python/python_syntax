Python Syntax

> import abcd as xyz: rename imported code as xyz
> from abcd import tt, uu: import specific variables from a module

> defining a class
	> class MyClass(object):
		> what to put int the parens?
			> this is the class that the new class that your are defining enherits from.  If you put object, that is a python class.

	> pass : a class has no contents
	
> method
	> def name(self):
		<what the method does>
	> you need to pass self, cause when you call a method you implicitly pass the instance.  So if you don't include self in the def then when you call the method there will be an argument passed and the method isn't expecting one which leads to error

	> setter method: you can set variables of an instance through a method
		> def name(self):
			self.var = 42
	> using such methods are a gateway to the instances state, ensuring the integrity of the data

	> getter method: gets a value of an instance

> __init__ 
	> set variables when you init an instance
	> __xys__ : means private
	> def __init__(self):
		print 'calling __init__'
		self.val = 0;
	> can pass arg: __init__(self, num):
		> me = myObj(5) : this is how you an arg to an init method
		> should include a validation try for input values
	> inheriting constructors : to inherit a constructor from a parent class put this code in child class __init__ method
		> super(ChildClass, self).__init__(arg)

	> inheritance
		> check the order of classes that a subclass inherits from
			> print obj.mro()

> magic methods
	> __add__ : if you include a method with that name in your class, then you can call that method by putting a '+' between two instances of that class
		> == : var.__eq__('abc')
		> len(var) : var.__len__()

> builtin classes
	> anything in python is a class
	> if you want to modify something like dictionary, then you can make a class that inherits from dictionary and does some other stuff then calls parent class' (dict) methods

> with : creates a block, that when it is done will close an open filehandle
	> performs cleanup when code leaves the block
	> calls __enter__ at the beginnint
	> calls __exit__ at the end
	> it's good to know this so that you can implement __enter__ and __exit__ in your own classes, and those methods will be called when used with "with" as shown below
		> with MyClass() as a
			a.do_something

> exceptions
	> best way to find out what exception is going to be raised is to try it and see what happens
	> ex: 
		> 	try:
				some code
			except ErrorType:
				print('trapped error')
				print('this is what happened')
	> or: 
			except(Error1, Error2)
	> trapping an error allows us to handle it as we please
	> set the error raised to a variable
		> except ZeroDivisionError, e:
			print(e.message)
			print(e.args)

> JSON
	> 	import json
		fh = open('data.json')
		data = json.load(fh) // data is of type dict

	> // write json to a file
		json.dump(data, fh) // where data is a python dictinary
		> json.dump(data, fh, indent=4, separators=(',', ': '))
			> json dump can take arguments to make the dump more readable

> logging : print statements while program is running
	> logging module
	> levels of logging
		> debug
		> info
		> warning
	> you can log to a file
		> file can be wiped before every run, or appended to the end
		> date option
		

> general
	> do what you want to do, then trap errors, that is a general practice in python.  For instance calling methods on objects that might throw an error

> debugging
	> PDB : python debugger
		> import pdb
		> put a line where you want to stop the program
			> pdb.set_trace()
		> in the terminal you can type out the names of variables, then when you are done inspecting type "continue"
		> "quit" : exit debugger
		> "n" : next: takes you to the next break
		> "s" : step: takes you to next line, will enter into other functions where next will skip over functions
		> "l" : shows you where you are in the code
		> "h" : help : list of commands that are available

> style
	> modules : all_lower_case
	> class : CamelCase
	> globals and locals : all_lower_case
	> fucntions/methods : all_lower_case
	> constants : ALL_CAPS

	> attributes
		> private : _private_name